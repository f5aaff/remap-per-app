#!/usr/bin/env bash

# globals
# set config to default, unless otherwise specified
CONFIG="${CONFIG:-$HOME/.config/remap-per-app.conf}"
STATE_DIR="/tmp/remap-per-app"
# set session type to x11 unless it's already set
SESSION_TYPE="${XDG_SESSION_TYPE:-x11}"
# set debug to 0 unless debug is set by user
DEBUG="${DEBUG:-0}"


# clean up all temp files from prior runs
rm -rf "$STATE_DIR" > /dev/null

# create the state directory in /tmp
mkdir -p "$STATE_DIR"

# declare an associative array var for STATE
declare -A STATE


# basic log function, just logs level and time stamp,
# and hides debug logs unless debug is active
log() {
    local level="$1"
    shift
    if [[ "$level" == "DEBUG" && "$DEBUG" != "1" ]]; then
        return
    fi
    echo "[$level] $(date '+%F %T') $*"
}

# Parse mappings into xbindkeys format
parse_x11_mappings() {
    local line="$1"
    echo "$line" | tr ',' '\n' | while read -r mapping; do
        mapping=$(echo "$mapping" | xargs)  # trim whitespace
        [[ -z "$mapping" ]] && continue

        local lhs=$(echo "$mapping" | cut -d'=' -f1 | xargs)
        local rhs=$(echo "$mapping" | cut -d'=' -f2 | xargs)

        echo "\"xdotool key --clearmodifiers $rhs\""
        echo "  $lhs"
    done
}

parse_evremap_mappings() {
    local line="$1"
    echo "$line" | tr ',' '\n' | while read -r mapping; do
        mapping=$(echo "$mapping" | xargs)  # trim whitespace
        [[ -z "$mapping" ]] && continue

        local lhs=$(echo "$mapping" | cut -d'=' -f1 | xargs)
        local rhs=$(echo "$mapping" | cut -d'=' -f2 | xargs)
        echo "[[remap]]"
        echo "input = [\"$lhs\"]"
        echo "output = [\"$rhs\"]"
    done
}

# Generate xbindkeys config for an app
generate_xbindkeys_config() {
    local app="$1"
    local buttons="$2"
    local keys="$3"
    local file="$STATE_DIR/$app.scm"
    # creates an anonymous file, echos the result of parse_x11_mappings into
    # this 'file', to be used in the remap application.
    > "$file"

    [[ -n "$buttons" ]] && parse_x11_mappings "$buttons" >> "$file"
    [[ -n "$keys" ]] && parse_x11_mappings "$keys" >> "$file"

    echo "$file"
}

generate_evremap_config() {
    local app="$1"
    local buttons="$2"
    local device="$3"
    local file="$STATE_DIR/$app.toml"

    > "$file"
    echo "device_name = \"$device\"" >> "$file"
    [[ -n "$buttons" ]] && parse_evremap_mappings "$buttons" >> "$file"

    echo "$file"

}

apply_x11_remap() {
    local app="$1"
    local mappings="$2"
    log DEBUG "$app" "$mappings"
    # skip current remap if a .pid is present for the given app.
    if [ -f "$STATE_DIR/$app.pid" ]; then
        log DEBUG "X11 remap for [$app] already running, skipping"
        return
    fi

    local config_file
    config_file=$(generate_xbindkeys_config "$app" "$mappings")

    if xbindkeys -f "$config_file" & then
        echo $! > "$STATE_DIR/$app.pid"
        log INFO "Applied X11 remap for [$app] using $config_file"
    else
        log ERROR "Failed to start xbindkeys for [$app]"
    fi
}

# Apply remaps for Wayland (Sway/wlroots)
apply_evremap_remap() {
    local app="$1"
    local mappings="$2"
    local device="$3"

    # If we've already applied for this app in this session, skip
    if [ -f "$STATE_DIR/$app.pid" ]; then
        log DEBUG "Wayland remap for [$app] already active, skipping"
        return
    fi

    local config_file
    config_file=$(generate_evremap_config "$app" "$mappings" "$device")

    if evremap remap "$config_file" & then
        echo $! > "$STATE_DIR/$app.pid"
        log INFO "Applied evremap remap for [$app] using $config_file"
    else
        log ERROR "Failed to start evremap for [$app]"
    fi
}


log INFO "Starting mouse remap daemon using config: $CONFIG"

# kill all the xbindkeys instances generated by potential prior instances
# fire off kill command for xbindkeys instances for every config present.
# terrible? yes. Working? also yes
for f in "$STATE_DIR"/*; do
    if [[ -f "$f" ]]; then
        pkill "xbindkeys -f $f" 2>/dev/null
    fi
done


while true; do
    match=""
    app=""
    mappings=""
    device=""

    while IFS= read -r line; do
        # Detect [Section]
        # https://regex101.com/r/WocPnX/1
        if [[ "$line" =~ ^\[(.+)\]$ ]]; then
            app="${BASH_REMATCH[1]}"
            match=""
            mappings=""
            device=""
        # parse out the 'match', denoting the application
        elif [[ "$line" =~ ^match ]]; then
            match=$(echo "$line" | cut -d'=' -f2- | xargs)
        # parse out the mappings line
        elif [[ "$line" =~ ^mappings ]]; then
            mappings=$(echo "$line" | cut -d'=' -f2- | xargs)
        if [[ "$line" =~ ^device ]]; then
            device=$(echo "$line" | cut -d'=' -f2- | xargs)
        fi
            # if match is empty, default to app name
            [[ -z "$match" ]] && match="$app"

            # Check if target process is running
            if pgrep -f -- "$match" >/dev/null; then
                if [[ "${STATE[$app]}" != "active" ]]; then
                    log INFO "Found process for [$app]"

                    if [[ "$SESSION_TYPE" == "x11" ]]; then
                        apply_x11_remap "$app" "$mappings"
                    elif [[ "$SESSION_TYPE" == "wayland" ]]; then
                        apply_evremap_remap "$app" "$mappings" "$device"
                        echo "wayland" > "$STATE_DIR/$app.pid"
                        log INFO "Applied Wayland remap for [$app]"
                    fi

                    STATE[$app]="active"
                fi
            else
                # Process not found: remove remap if active
                if [[ "${STATE[$app]}" != "inactive" ]]; then
                    log INFO "No process found for [$app] (removing remap if active)"
                    # kill the remap process PID
                    kill $(cat "$STATE_DIR/$app.pid") 2>/dev/null
                    rm -f "$STATE_DIR/$app.pid"
                    log INFO "Removed remap for [$app]"
                    fi
                        STATE[$app]="inactive"
                fi
            fi
    done < "$CONFIG"

    sleep 2
done

